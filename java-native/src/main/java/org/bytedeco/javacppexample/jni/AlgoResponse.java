// Targeted by JavaCPP version 1.5.7: DO NOT EDIT THIS FILE

package org.bytedeco.javacppexample.jni;

import org.bytedeco.javacpp.BytePointer;
import org.bytedeco.javacpp.Loader;
import org.bytedeco.javacpp.Pointer;
import org.bytedeco.javacpp.annotation.ByRef;
import org.bytedeco.javacpp.annotation.NoOffset;
import org.bytedeco.javacpp.annotation.Properties;
import org.bytedeco.javacpp.annotation.StdString;


/**
 * 注意: 经过使用swig调用c++测试发现, 如果一个类使用了智能指针进行包裹, eg: std::shared_ptr<AlgoResponse>, 
 * 那 AlgoResponse类中再使用智能指针包裹其他类就会出现内存泄漏的问题
 * 
 * 假如std::shared_ptr<AlgoResponse>的AlgoResponse类中使用了std::shared_ptr<MediaData>
 * 包裹MediaData就会出现内存泄漏的风险
 * 
 */
@NoOffset @Properties(inherit = org.bytedeco.javacppexample.presets.algo_service.class)
public class AlgoResponse extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public AlgoResponse(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public AlgoResponse(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public AlgoResponse position(long position) {
        return (AlgoResponse)super.position(position);
    }
    @Override public AlgoResponse getPointer(long i) {
        return new AlgoResponse((Pointer)this).offsetAddress(i);
    }


    public AlgoResponse() { super((Pointer)null); allocate(); }
    private native void allocate();

    public native long get_length();
    public native void set_length(long length);

    public native @StdString BytePointer get_body();
    public native void set_body(@StdString BytePointer data);
    public native void set_body(@StdString String data);
    
    public native @ByRef MediaData get_media_data();
    public native void set_media_data(@ByRef MediaData media_data);
    
    // 一定要加上析构函数，否则会有内存溢出问题
}
