server:
  port: 8080
# 日志配置
logging:
  level:
    # 注意注意注意 一定要修改成自己的包名
    # 如果你只需要输出info，可以不用修改成自己的包名，但是如果为其他级别，
    # 比如debug必修改成自己的包名才会生效
    com.concise.demo: debug
  file:
    path: /mnt/logs/springboot-demo-rabbitmq
spring:
  profiles:
    active: dev,rabbitmq-demo
  # Redis数据库索引（默认为0）
  redis:
    database: 0
    # Redis服务器地址
    host: 192.168.190.28
    # Redis服务器连接端口
    port: 36379
    # Redis服务器连接密码（默认为空）
    password: QWER@1234
    lettuce:
      pool:
        #连接池最大连接数（使用负值表示没有限制）
        max-active: 100
        # 连接池最大阻塞等待时间（使用负值表示没有限制）
        max-wait: -1ms
        # 连接池中的最大空闲连接
        max-idle: 8
        # 连接池中的最小空闲连接
        min-idle: 0
  rabbitmq:
    host: work01.server.com
    port: 5672
    username: admin
    password: QWER@1234
    virtualHost: /
    publisher-returns: true  #消息发送后,如果发送失败,则会返回失败信息信息
    #connection-timeout: 15000
    connection-timeout: 1500
    template:
      # 触发returnedMessage回调必须设置mandatory=true, 否则Exchange没有找到Queue就会丢弃掉消息, 而不会触发回调
      mandatory: true
    listener: #加了2下面2个属性,消费消息的时候,就必须发送ack确认,不然消息永远还在队列中
      direct:
        # 手动确认
        acknowledge-mode: manual
      simple:
        # 手动确认
        acknowledge-mode: manual
        # 每次从RabbitMQ获取的消息数量
        prefetch: 1
        default-requeue-rejected: false
        # 每个队列启动的消费者数量
        concurrency: 1
        # 每个队列最大的消费者数量
        max-concurrency: 1
        retry:
          #最大重试次数
          max-attempts: 5
          # 是否开启消费者重试（为false时关闭消费者重试，这时消费端代码异常会一直重复收到消息）
          enabled: true
          #最大间隔时间
          max-interval: 20000ms
          # 重试间隔时间
          initial-interval: 3000ms
          #乘子  重试间隔*乘子得出下次重试间隔  3s  6s  12s  24s  此处24s>20s  走20s
          multiplier: 2

    # 消息发送后,如果发送成功到队列,则会回调成功信息
    publisher-confirm-type: correlated
